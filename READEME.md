@[TOC](耍流氓方式保活service)

## 进程优先级：

1. 前台进程

用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：

- 托管用户正在交互的Activity已调用Activity的onResume()方法
- 托管某个Service，后者绑定到用户正在交互的 Activity
- 托管正在“前台”运行的Service服务已调用startForeground()
- 托管正执行一个生命周期回调的Service (onCreate() 、onStart()或onDestroy())
- 托管正执行其onReceive()方法的BroadcastReceiver

　　通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。

2. 可见进程

　　没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：

- 托管不在前台、但仍对用户可见的Activity已调用其onPause()方法。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。
- 托管绑定到可见（或前台）Activity 的Service。

　　可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。

3. 服务进程

　　正在运行已使用startService()方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。

4. 后台进程

　　包含目前对用户不可见的 Activity 的进程已调用 Activity 的onStop()方法。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅Activity文档。

5. 空进程

　　不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。

后台杀死进程是按照优先级来进行的。

## 常见的几种情况：

1. 应用正在运行，这个时候内存不足回收杀进程  
    解决：
    1. 提高进程的优先级，其实就是减小进程的p->oomkilladj（越小越重要），如启动Service调用startForeground()尽量提高进程的优先级；
    2. 当应用退到后台适当释放资源然后降低APP的内存占用量，因为在oom_adj相同的时候，会优先干掉内存消耗大的进程；

2. 很多情况下用了系统自带或者第三方的清理软件，也会杀我们的进程  
   解决：  
   `启动两个进程，相互唤醒`

3. 各大Rom厂商在应用退出的时候会清理杀进程
   解决：  
   `JobScheduler`,定时保活

    <font color = red>JobService的代码在Android7.0以前是正常按照设置的执行周期执行的；但是由于Android官方在7.0以后为了不让应用占用系统太多资源以及电池优化，对定时任务JobService设了限制，强制了执行最小时间周期不能小于15分钟，那是不是这样呢？我们对比一下Android7.0以前跟7.0以后的源码；</font>

   使用workManager试一下










 


      
     
 

